#!/bin/bash

# Cudo - CUDA Development Environment Manager
# Usage: cudo [command] [options]

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
# 如果 SCRIPT_DIR 指向的是主脚本所在目录，那么 Python 脚本应该在 scripts 子目录中
PYTHON_SCRIPT_DIR="$SCRIPT_DIR/scripts"
PROJECT_ROOT="$(pwd)"

# Default Config
DEFAULT_CUDA_VERSION="12.4.0"
DEFAULT_UBUNTU_VERSION="20.04"
DEFAULT_WITH_TOOLKIT="false"
DEFAULT_PYTHON_VERSION="3.10"
# 注意：实际的镜像名称会在 build 时加上 UNIQUE_HASH
DEFAULT_IMAGE_NAME_BASE="cuda-project-$(basename "$PROJECT_ROOT" | tr '[:upper:]' '[:lower:]')"

CONFIG_DIR="$PROJECT_ROOT/.cudo"

CONFIG_FILE="$CONFIG_DIR/config"
DOCKERFILE="$CONFIG_DIR/Dockerfile"
DOCKER_COMPOSE_FILE="$CONFIG_DIR/docker-compose.yml"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Log Function
log_info() { echo -e "${BLUE}$1${NC}"; }
log_success() { echo -e "${GREEN} $1${NC}"; }
log_warning() { echo -e "${YELLOW}$1${NC}"; }
log_error() { echo -e "${RED}$1${NC}"; }


# Global configuration directory (stores all project information)
# Use system-wide directory for multi-user support
GLOBAL_CONFIG_DIR="/var/lib/cudo-global"
# Try to create system directory first
mkdir -p "$GLOBAL_CONFIG_DIR" 2>/dev/null || true
# Ensure the global directory is writable, otherwise disable the tool
if [ ! -w "$GLOBAL_CONFIG_DIR" ]; then
    log_error "Global configuration directory $GLOBAL_CONFIG_DIR is not writable"
    log_error "Please ensure the directory exists and has proper permissions:"
    log_error "  sudo mkdir -p $GLOBAL_CONFIG_DIR"
    log_error "  sudo chmod 777 $GLOBAL_CONFIG_DIR"
    exit 1
fi

save_config() {
    # 不在这里生成哈希，哈希应该在 build 时或检测到拷贝时生成
    # 如果 UNIQUE_HASH 为空，说明配置有问题
    if [ -z "$UNIQUE_HASH" ]; then
        log_error "UNIQUE_HASH is not set. This should not happen."
        exit 1
    fi
    
    cat > "$CONFIG_FILE" << EOF
CUDA_VERSION=$CUDA_VERSION
UBUNTU_VERSION=$UBUNTU_VERSION
WITH_TOOLKIT=$WITH_TOOLKIT
PYTHON_VERSION=$PYTHON_VERSION
IMAGE_NAME=$IMAGE_NAME
CUDA_VARIANT=$CUDA_VARIANT
UNIQUE_HASH=$UNIQUE_HASH
EOF
    log_success "Configuration saved"
}

save_to_global() {
    local project_name=$(basename "$PROJECT_ROOT")
    local unique_hash=$UNIQUE_HASH
    local unique_id="${project_name}-${unique_hash}"
    local global_config_file="$GLOBAL_CONFIG_DIR/${unique_id}.conf"
    
    # 获取当前项目目录的 inode
    local current_inode=$(stat -c '%i' "$PROJECT_ROOT" 2>/dev/null || stat -f '%i' "$PROJECT_ROOT" 2>/dev/null)
    
    # 检查是否已存在相同路径的配置
    local existing_config_by_path=$(find "$GLOBAL_CONFIG_DIR" -name "*.conf" -exec grep -l "PROJECT_PATH=$PROJECT_ROOT$" {} \; 2>/dev/null | head -1)
    
    if [ -n "$existing_config_by_path" ]; then
        # 同一路径，只需更新配置，不删除
        log_info "Updating existing configuration for current path"
    fi
    
    # 检查是否已存在相同 unique_hash 的配置（但不同路径）
    local existing_config_by_hash=$(find "$GLOBAL_CONFIG_DIR" -name "*.conf" -exec grep -l "UNIQUE_HASH=$unique_hash$" {} \; 2>/dev/null | head -1)
    
    if [ -n "$existing_config_by_hash" ]; then
        # 获取原始项目路径
        local original_project_path=$(grep "PROJECT_PATH=" "$existing_config_by_hash" | cut -d'=' -f2-)
        
        if [ "$original_project_path" != "$PROJECT_ROOT" ]; then
            # 路径不同，需要判断是移动还是拷贝
            
            # 获取原始路径的 inode（如果路径仍然存在）
            local original_inode=""
            if [ -d "$original_project_path" ]; then
                original_inode=$(stat -c '%i' "$original_project_path" 2>/dev/null || stat -f '%i' "$original_project_path" 2>/dev/null)
            fi
            
            if [ -n "$original_inode" ] && [ "$original_inode" = "$current_inode" ]; then
                # inode 相同 → 这是移动操作
                log_info "Detected project move from $original_project_path to $PROJECT_ROOT"
                log_info "Updating configuration with new path, keeping hash: $unique_hash"
                # 删除旧配置文件
                rm -f "$existing_config_by_hash"
            elif [ -d "$original_project_path/.cudo" ]; then
                # 原始路径存在且 inode 不同 → 这是拷贝操作
                log_warning "=========================================="
                log_warning "Detected project copy!"
                log_warning "Original: $original_project_path"
                log_warning "Copy: $PROJECT_ROOT"
                log_warning "=========================================="
                
                # 生成新的唯一哈希
                UNIQUE_HASH=$(openssl rand -hex 4)
                unique_hash=$UNIQUE_HASH
                unique_id="${project_name}-${unique_hash}"
                global_config_file="$GLOBAL_CONFIG_DIR/${unique_id}.conf"
                
                # 更新镜像名称以包含新的哈希
                # 从旧的 IMAGE_NAME 中提取基础名称（去掉旧哈希）
                local old_hash=$(grep "UNIQUE_HASH=" "$existing_config_by_hash" | cut -d'=' -f2)
                local image_name_base="${IMAGE_NAME%-$old_hash}"
                IMAGE_NAME="${image_name_base}-${UNIQUE_HASH}"
                
                log_warning "Generated new unique hash: $unique_hash"
                log_warning "New image name: $IMAGE_NAME"
                log_warning ""
                log_warning "IMPORTANT: You must rebuild the image for this copied project!"
                log_warning "Run: cudo build"
                log_warning "=========================================="
                
                # 更新本地配置文件
                cat > "$CONFIG_FILE" << EOF
CUDA_VERSION=$CUDA_VERSION
UBUNTU_VERSION=$UBUNTU_VERSION
WITH_TOOLKIT=$WITH_TOOLKIT
PYTHON_VERSION=$PYTHON_VERSION
IMAGE_NAME=$IMAGE_NAME
CUDA_VARIANT=$CUDA_VARIANT
UNIQUE_HASH=$UNIQUE_HASH
EOF
                log_success "Configuration saved with new hash"
                
                # 重新生成 docker-compose.yml 文件以使用新的服务名和镜像名
                generate_docker_compose "$IMAGE_NAME"
                log_info "Updated docker-compose.yml with new service name and image name"
            else
                # 原始路径不存在 → 这是移动操作（原路径已删除）
                log_info "Original path no longer exists, treating as move operation"
                log_info "Updating configuration with new path, keeping hash: $unique_hash"
                # 删除旧配置文件
                rm -f "$existing_config_by_hash"
            fi
        fi
    fi
    
    cat > "$global_config_file" << EOF
PROJECT_NAME=$project_name
PROJECT_PATH=$PROJECT_ROOT
CUDA_VERSION=$CUDA_VERSION
UBUNTU_VERSION=$UBUNTU_VERSION
WITH_TOOLKIT=$WITH_TOOLKIT
PYTHON_VERSION=$PYTHON_VERSION
IMAGE_NAME=$IMAGE_NAME
CUDA_VARIANT=$CUDA_VARIANT
CREATED_TIME="$(date '+%Y-%m-%d %H:%M:%S')"
LAST_UPDATED="$(date '+%Y-%m-%d %H:%M:%S')"
UNIQUE_HASH=$unique_hash
UNIQUE_ID=$unique_id
STATUS=active
EOF
    log_success "Configuration saved to global storage: $unique_id"
}

remove_from_global() {
    local unique_hash=$UNIQUE_HASH
    local project_name=$(basename "$PROJECT_ROOT")
    local unique_id="${project_name}-${unique_hash}"
    local global_config_file="$GLOBAL_CONFIG_DIR/${unique_id}.conf"
    
    if [ -f "$global_config_file" ]; then
        rm -f "$global_config_file"
        log_success "Removed from global storage: $unique_id"
    fi
}

# 检查并更新全局配置状态
update_global_status() {
    # 遍历所有全局配置文件
    for config_file in "$GLOBAL_CONFIG_DIR"/*.conf; do
        if [ -f "$config_file" ]; then
            source "$config_file"
            
            # 检查项目路径是否还存在容器配置文件夹
            local config_dir="$PROJECT_PATH/.cudo"
            if [ ! -d "$config_dir" ]; then
                # 标记为已删除或已移动
                sed -i "s|STATUS=.*|STATUS=deleted|" "$config_file"
                sed -i "s|LAST_UPDATED=.*|LAST_UPDATED=\"$(date '+%Y-%m-%d %H:%M:%S')\"|" "$config_file"
            else
                # 确保状态是 active
                sed -i "s|STATUS=.*|STATUS=active|" "$config_file"
                sed -i "s|LAST_UPDATED=.*|LAST_UPDATED=\"$(date '+%Y-%m-%d %H:%M:%S')\"|" "$config_file"
            fi
        fi
    done
}

# 清理已删除/移动的项目配置
cleanup_deleted_projects() {
    local deleted_count=0
    
    # 遍历所有全局配置文件
    for config_file in "$GLOBAL_CONFIG_DIR"/*.conf; do
        if [ -f "$config_file" ]; then
            local status=$(grep "STATUS=" "$config_file" | cut -d'=' -f2)
            
            if [ "$status" = "deleted" ]; then
                local project_name=$(grep "PROJECT_NAME=" "$config_file" | cut -d'=' -f2)
                local unique_id=$(grep "UNIQUE_ID=" "$config_file" | cut -d'=' -f2)
                
                rm -f "$config_file"
                deleted_count=$((deleted_count + 1))
                log_info "Removed deleted project: $unique_id"
            fi
        fi
    done
    
    if [ $deleted_count -eq 0 ]; then
        log_info "No deleted projects to clean up"
    else
        log_success "Cleaned up $deleted_count deleted project(s)"
    fi
}

# 清理旧的全局配置文件（基于项目名称的）
cleanup_old_global_configs() {
    local project_name=$(basename "$PROJECT_ROOT")
    local unique_hash=$UNIQUE_HASH
    local current_unique_id="${project_name}-${unique_hash}"
    
    # 查找所有相同项目名称的旧配置文件
    for old_config in "$GLOBAL_CONFIG_DIR/${project_name}.conf"*; do
        if [ -f "$old_config" ] && [[ "$old_config" != *"$current_unique_id.conf" ]]; then
            rm -f "$old_config"
            log_info "Cleaned up old global config: $(basename "$old_config")"
        fi
    done
}

# 加载配置
load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
        # 如果配置中没有 UNIQUE_HASH，这是一个错误状态
        if [ -z "$UNIQUE_HASH" ]; then
            log_error "Configuration file is missing UNIQUE_HASH. Please rebuild the project."
            return 1
        fi
        return 0
    else
        return 1
    fi
}

# 检查依赖
check_dependencies() {
    local missing=()
    
    if ! command -v docker &> /dev/null; then
        missing+=("docker")
    fi
    
    if ! command -v docker-compose &> /dev/null; then
        missing+=("docker-compose")
    fi
    
    if ! command -v envsubst &> /dev/null; then
        missing+=("envsubst (gettext)")
    fi
    
    if [ ${#missing[@]} -ne 0 ]; then
        log_error "Missing dependencies: ${missing[*]}"
        echo "Please install the following software:"
        for dep in "${missing[@]}"; do
            case $dep in
                "docker")
                    echo "  Docker: https://docs.docker.com/get-docker/"
                    ;;
                "docker-compose")
                    echo "  Docker Compose: https://docs.docker.com/compose/install/"
                    ;;
                "envsubst (gettext)")
                    echo "  envsubst:"
                    echo "    Ubuntu/Debian: sudo apt-get install gettext"
                    echo "    CentOS/RHEL: sudo yum install gettext"
                    ;;
            esac
        done
        exit 1
    fi
}

# 生成 Dockerfile
generate_dockerfile() {
    local cuda_version=$1
    local ubuntu_version=$2
    local cuda_variant=$3
    local python_version=$4
    
    # 获取当前用户信息
    local current_user=$(id -un)
    local current_uid=$(id -u)
    local current_gid=$(id -g)
    
    cat > "$DOCKERFILE" << EOF
FROM nvidia/cuda:${cuda_version}-${cuda_variant}-ubuntu${ubuntu_version}

ENV LANG=C.UTF-8 LC_ALL=C.UTF-8

# 安装基础工具
RUN apt-get update && apt-get install -y --no-install-recommends \\
    wget \\
    bzip2 \\
    ca-certificates \\
    libglib2.0-0 \\
    libxext6 \\
    libsm6 \\
    libxrender1 \\
    libgl1-mesa-glx \\
    git \\
    build-essential \\
    mercurial \\
    subversion \\
    tmux \\
    vim \\
    curl \\
    sudo \\
    && apt-get clean \\
    && rm -rf /var/lib/apt/lists/*

# 创建工作目录
WORKDIR /workspace

# 创建用户并设置权限（在安装 Miniconda 之前）
RUN groupadd -g ${current_gid} ${current_user} && \\
    useradd -m -u ${current_uid} -g ${current_gid} -s /bin/bash ${current_user} && \\
    echo "${current_user} ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers.d/${current_user} && \\
    chmod 0440 /etc/sudoers.d/${current_user} && \\
    chown -R ${current_user}:${current_user} /workspace

# 切换用户（以便以用户身份安装 Miniconda）
USER ${current_user}

# 安装 Miniconda 到用户 home 目录
RUN wget --quiet https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda.sh && \\
    /bin/bash ~/miniconda.sh -b -p /home/${current_user}/miniconda3 && \\
    rm ~/miniconda.sh

# 设置 conda 环境变量
ENV PATH /home/${current_user}/miniconda3/bin:\$PATH

# 配置 conda 环境（以用户身份运行）
RUN conda config --set always_yes yes --set changeps1 no && \\
    conda clean -ya && \\
    conda tos accept --override-channels --channel https://repo.anaconda.com/pkgs/main && \\
    conda tos accept --override-channels --channel https://repo.anaconda.com/pkgs/r && \\
    conda install python=${python_version} && \\
    conda config --set always_yes false --set changeps1 yes

# 为用户配置 conda（添加到 bashrc）
RUN echo ". /home/${current_user}/miniconda3/etc/profile.d/conda.sh" >> ~/.bashrc && \\
    echo "conda activate base" >> ~/.bashrc

CMD ["/bin/bash"]
EOF
    log_success "Dockerfile generated"
}

# 生成 docker-compose.yml
generate_docker_compose() {
    local image_name=$1
    
    # 使用唯一哈希生成所有名称，避免冲突
    local service_name="cuda-project-${UNIQUE_HASH}"
    local container_name="${service_name}-container"
    
    cat > "$DOCKER_COMPOSE_FILE" << EOF
services:
  ${service_name}:
    build:
      context: .
      dockerfile: Dockerfile
    image: ${image_name}
    network_mode: host
    container_name: ${container_name}
    runtime: nvidia
    environment:
      - NVIDIA_VISIBLE_DEVICES=all
    volumes:
      - ..:/workspace
      - /tmp/.X11-unix:/tmp/.X11-unix
      - /dev/shm:/dev/shm
    working_dir: /workspace
    stdin_open: true
    tty: true
    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              count: all
              capabilities: [gpu]
EOF
    log_success "docker-compose.yml generated"
    log_info "Service name: ${service_name}"
    log_info "Container name: ${container_name}"
}

# 构建镜像
build_image() {
    log_info "Starting image build..."
    cd "$CONFIG_DIR"
    
    if docker_compose_cmd build; then
        log_success "Image build successful!"
        log_info "Image name: $IMAGE_NAME"
        log_info "Working directory: $PROJECT_ROOT"
    else
        log_error "Image build failed!"
        exit 1
    fi
}

# 获取容器资源使用信息
get_container_stats() {
    local container_name="cuda-project-${UNIQUE_HASH}-container"
    local stats_output
    
    if docker ps --format "table {{.Names}}" | grep -q "$container_name"; then
        # 获取 CPU 使用率
        local cpu_usage=$(docker stats --no-stream --format "{{.CPUPerc}}" "$container_name" 2>/dev/null | head -1 || echo "N/A")
        
        # 获取内存使用
        local mem_usage=$(docker stats --no-stream --format "{{.MemUsage}}" "$container_name" 2>/dev/null | head -1 || echo "N/A")
        
        # 获取内存限制
        local mem_limit=$(docker stats --no-stream --format "{{.MemPerc}}" "$container_name" 2>/dev/null | head -1 || echo "N/A")
        
        echo "$cpu_usage|$mem_usage|$mem_limit"
    else
        echo "N/A|N/A|N/A"
    fi
}

# 获取容器详细信息
get_container_info() {
    local container_name="cuda-project-${UNIQUE_HASH}-container"
    local info_output
    
    if docker ps -a --format "table {{.Names}}" | grep -q "$container_name"; then
        # 获取容器状态
        local status=$(docker ps -a --format "table {{.Names}}\t{{.Status}}" | grep "$container_name" | awk '{print $2}')
        
        # 获取创建时间
        local created=$(docker inspect --format='{{.Created}}' "$container_name" 2>/dev/null | cut -d'T' -f1 || echo "N/A")
        
        # 获取端口映射
        local ports=$(docker inspect --format='{{range $p, $conf := .NetworkSettings.Ports}}{{(index $conf 0).HostPort}}->{{$p}} {{end}}' "$container_name" 2>/dev/null || echo "N/A")
        
        echo "$status|$created|$ports"
    else
        echo "nonexistent|N/A|N/A"
    fi
}

# 检查镜像是否存在
check_image_exists() {
    docker image inspect "$1" > /dev/null 2>&1
}

# 获取服务名称
get_service_name() {
    local image_name=$1
    echo "${image_name}" | sed 's/[^a-zA-Z0-9_-]//g'
}

# Docker Compose 命令兼容性处理
docker_compose_cmd() {
    # 优先使用 docker compose (V2)
    if command -v docker > /dev/null && docker compose version > /dev/null 2>&1; then
        docker compose "$@"
    # 回退到 docker-compose (V1)
    elif command -v docker-compose > /dev/null; then
        docker-compose "$@"
    else
        log_error "docker compose or docker-compose command not found"
        exit 1
    fi
}

# 检查容器状态
check_container_status() {
    local container_name="cuda-project-${UNIQUE_HASH}-container"
    if docker ps -a --format "table {{.Names}}\t{{.Status}}" | grep -q "$container_name"; then
        local status=$(docker ps -a --format "table {{.Names}}\t{{.Status}}" | grep "$container_name" | awk '{print $2}')
        if [[ "$status" == Up* ]]; then
            echo "running"
        else
            echo "stopped"
        fi
    else
        echo "nonexistent"
    fi
}

# 验证镜像名称
validate_image_name() {
    local image_name=$1
    
    # Docker 镜像名称规则：
    # - 只能包含小写字母、数字、连字符、下划线和点号
    # - 不能以连字符、下划线或点号开头或结尾
    # - 不能包含连续的点号
    
    # 检查是否只包含允许的字符
    if ! [[ "$image_name" =~ ^[a-z0-9._-]+$ ]]; then
        log_error "Invalid image name: '$image_name'"
        log_error "Image names can only contain lowercase letters, numbers, dots, hyphens, and underscores"
        return 1
    fi
    
    # 检查开头字符
    if [[ "$image_name" =~ ^[._-] ]]; then
        log_error "Invalid image name: '$image_name'"
        log_error "Image names cannot start with a dot, hyphen, or underscore"
        return 1
    fi
    
    # 检查结尾字符
    if [[ "$image_name" =~ [._-]$ ]]; then
        log_error "Invalid image name: '$image_name'"
        log_error "Image names cannot end with a dot, hyphen, or underscore"
        return 1
    fi
    
    # 检查连续的点号
    if [[ "$image_name" =~ \.\. ]]; then
        log_error "Invalid image name: '$image_name'"
        log_error "Image names cannot contain consecutive dots"
        return 1
    fi
    
    # 检查长度（Docker 限制为 128 个字符）
    if [ ${#image_name} -gt 128 ]; then
        log_error "Invalid image name: '$image_name'"
        log_error "Image names cannot exceed 128 characters"
        return 1
    fi
    
    return 0
}

# 自动补全 CUDA 版本号
normalize_cuda_version() {
    local cuda_version=$1
    
    # 如果版本号只有两个部分（如 12.4），补全为三个部分（12.4.0）
    if [[ "$cuda_version" =~ ^[0-9]+\.[0-9]+$ ]]; then
        echo "${cuda_version}.0"
    else
        echo "$cuda_version"
    fi
}

# 检查 Docker 镜像是否存在
check_docker_image_exists() {
    local cuda_version=$1
    local ubuntu_version=$2
    local cuda_variant=$3
    
    local image_name="nvidia/cuda:${cuda_version}-${cuda_variant}-ubuntu${ubuntu_version}"
    
    log_info "Checking if Docker image exists: $image_name"
    
    # 首先检查本地是否有该镜像
    if docker image inspect "$image_name" > /dev/null 2>&1; then
        log_success "Docker image found locally: $image_name"
        return 0
    fi
    
    # 本地没有，直接尝试拉取镜像
    log_info "Image not found locally, pulling from remote registry..."
    if docker pull "$image_name"; then
        log_success "Docker image pulled successfully: $image_name"
        return 0
    else
        log_error "Docker image not found: $image_name"
        log_error ""
        log_error "This CUDA/Ubuntu combination may not be available."
        log_error "Please check available images at: https://hub.docker.com/r/nvidia/cuda/tags"
        log_error ""
        return 1
    fi
}

# 检查 Python 版本是否有效
check_python_version() {
    local python_version=$1
    
    # 验证 Python 版本格式 (major.minor)
    if ! [[ "$python_version" =~ ^[0-9]+\.[0-9]+$ ]]; then
        log_error "Invalid Python version format: '$python_version'"
        log_error "Python version should be in format: major.minor (e.g., 3.10, 3.11)"
        return 1
    fi
    
    # 提取主版本和次版本
    local major_version=$(echo "$python_version" | cut -d. -f1)
    local minor_version=$(echo "$python_version" | cut -d. -f2)
    
    # 检查主版本是否为 3
    if [ "$major_version" -ne 3 ]; then
        log_error "Unsupported Python major version: $major_version"
        log_error "Only Python 3.x versions are supported"
        return 1
    fi
    
    # 检查次版本是否在合理范围内 (3.6 到 3.14)
    if [ "$minor_version" -lt 6 ] || [ "$minor_version" -gt 14 ]; then
        log_error "Unsupported Python version: $python_version"
        log_error "Supported Python versions are 3.6 to 3.14"
        return 1
    fi
    
    return 0
}

# 构建命令
build_command() {
    mkdir -p $CONFIG_DIR
    
    # 尝试加载现有配置以保留哈希
    local existing_hash=""
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
        existing_hash="$UNIQUE_HASH"
    fi
    
    # 解析构建参数
    local cuda_version=$DEFAULT_CUDA_VERSION
    local ubuntu_version=$DEFAULT_UBUNTU_VERSION
    local with_toolkit=$DEFAULT_WITH_TOOLKIT
    local python_version=$DEFAULT_PYTHON_VERSION
    local image_name_base=$DEFAULT_IMAGE_NAME_BASE
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -c|--cuda-version)
                cuda_version="$2"
                # 自动补全 CUDA 版本号
                cuda_version=$(normalize_cuda_version "$cuda_version")
                shift 2
                ;;
            -u|--ubuntu-version)
                ubuntu_version="$2"
                shift 2
                ;;
            -t|--with-toolkit)
                with_toolkit="true"
                shift
                ;;
            -p|--python-version)
                python_version="$2"
                # 立即验证 Python 版本
                if ! check_python_version "$python_version"; then
                    exit 1
                fi
                shift 2
                ;;
            -i|--image-name)
                image_name_base="$2"
                # 立即验证镜像名称
                if ! validate_image_name "$image_name_base"; then
                    log_error ""
                    log_error "Valid image name examples:"
                    log_error "  my-project"
                    log_error "  cuda-env-1"
                    log_error "  test.image_123"
                    log_error ""
                    log_error "Invalid image name examples:"
                    log_error "  My-Project (uppercase not allowed)"
                    log_error "  -project (cannot start with hyphen)"
                    log_error "  project. (cannot end with dot)"
                    log_error "  project..name (consecutive dots not allowed)"
                    exit 1
                fi
                shift 2
                ;;
            *)
                log_error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done
    
    # 根据是否包含 toolkit 设置变体
    if [ "$with_toolkit" = "true" ]; then
        local cuda_variant="devel"
    else
        local cuda_variant="base"
    fi
    
    # 如果已有哈希则保留，否则生成新的（必须在设置 IMAGE_NAME 之前）
    if [ -n "$existing_hash" ]; then
        UNIQUE_HASH="$existing_hash"
        log_info "Using existing hash: $UNIQUE_HASH"
    else
        UNIQUE_HASH=$(openssl rand -hex 4)
        log_info "Generated new hash: $UNIQUE_HASH"
    fi
    
    # 设置全局变量用于保存配置
    CUDA_VERSION=$cuda_version
    UBUNTU_VERSION=$ubuntu_version
    WITH_TOOLKIT=$with_toolkit
    PYTHON_VERSION=$python_version
    # 镜像名称包含哈希值，确保每个项目有独立的镜像
    IMAGE_NAME="${image_name_base}-${UNIQUE_HASH}"
    CUDA_VARIANT=$cuda_variant
    
    echo "Build configuration:"
    echo "  CUDA version: $CUDA_VERSION"
    echo "  Ubuntu version: $UBUNTU_VERSION"
    echo "  CUDA variant: $CUDA_VARIANT"
    echo "  Python version: $PYTHON_VERSION"
    echo "  Image name: $IMAGE_NAME"
    echo "  Project path: $PROJECT_ROOT"
    echo "  Unique hash: $UNIQUE_HASH"
    
    # 检查依赖
    check_dependencies
    
    # 检查 Docker 基础镜像是否存在
    if ! check_docker_image_exists "$CUDA_VERSION" "$UBUNTU_VERSION" "$CUDA_VARIANT"; then
        log_error "Build aborted: Base Docker image not available"
        exit 1
    fi
    
    # 生成配置文件
    generate_dockerfile "$CUDA_VERSION" "$UBUNTU_VERSION" "$CUDA_VARIANT" "$PYTHON_VERSION"
    generate_docker_compose "$IMAGE_NAME"
    save_config
    
    # 构建镜像
    build_image
    
    # 清理旧的全局配置文件
    cleanup_old_global_configs
    
    # 保存到全局配置
    save_to_global
}

# 运行命令（进入容器）
run_command() {
    mkdir -p $CONFIG_DIR

    if ! load_config; then
        log_error "Configuration file not found, please run build command first: cudo build"
        exit 1
    fi
    
    # 检查拷贝/移动并更新全局配置
    # 这会在检测到拷贝时自动生成新哈希和新镜像名
    save_to_global
    
    # 在检查拷贝后，再检查镜像是否存在
    if ! check_image_exists "$IMAGE_NAME"; then
        log_error "=========================================="
        log_error "Environment is broken!"
        log_error "=========================================="
        log_error "Image '$IMAGE_NAME' does not exist."
        log_error ""
        log_error "This usually happens when:"
        log_error "  1. The project was moved and the old image was deleted"
        log_error "  2. The image was manually removed"
        log_error "  3. Docker was restore/cleaned"
        log_error ""
        log_error "To fix this, rebuild the environment:"
        log_error "  cudo build"
        log_error "=========================================="
        exit 1
    fi
    
    local status=$(check_container_status "$IMAGE_NAME")
    local container_name="cuda-project-${UNIQUE_HASH}-container"
    case $status in
        "running")
            log_info "Entering container..."
            docker exec -it "$container_name" bash
            ;;
        "stopped")
            log_info "Starting container and entering..."
            cd "$CONFIG_DIR"
            docker_compose_cmd up -d
            sleep 2
            docker exec -it "$container_name" bash
            ;;
        "nonexistent")
            log_info "Creating and starting container..."
            cd "$CONFIG_DIR"
            docker_compose_cmd up -d
            sleep 2
            docker exec -it "$container_name" bash
            ;;
    esac
}

# 状态命令
status_command() {
    mkdir -p $CONFIG_DIR

    if ! load_config; then
        log_error "Configuration file not found, please run build command first: cudo build"
        exit 1
    fi
    
    save_to_global
    
    local status=$(check_container_status "$IMAGE_NAME")
    case $status in
        "running")
            log_success "Container is running"
            ;;
        "stopped")
            log_warning "Container is stopped"
            ;;
        "nonexistent")
            log_info "Container does not exist"
            ;;
    esac
}

# 启动命令
start_command() {
    mkdir -p $CONFIG_DIR

    if ! load_config; then
        log_error "Configuration file not found, please run build command first: cudo build"
        exit 1
    fi
    
    save_to_global
    
    log_info "Starting container..."
    cd "$CONFIG_DIR"
    docker_compose_cmd start
}

# 停止命令
stop_command() {
    mkdir -p $CONFIG_DIR

    if ! load_config; then
        log_error "Configuration file not found, please run build command first: cudo build"
        exit 1
    fi
    
    save_to_global
    
    log_info "Stopping container..."
    cd "$CONFIG_DIR"
    docker_compose_cmd stop
}

# 重启命令
restart_command() {
    mkdir -p $CONFIG_DIR

    if ! load_config; then
        log_error "Configuration file not found, please run build command first: cudo build"
        exit 1
    fi
    
    save_to_global
    
    log_info "Restarting container..."
    cd "$CONFIG_DIR"
    docker_compose_cmd restart
}

# commit
commit_command() {
    mkdir -p $CONFIG_DIR

    if ! load_config; then
        log_error "Configuration file not found, please run build command first: cudo build"
        exit 1
    fi
    
    save_to_global
    
    local container_name="cuda-project-${UNIQUE_HASH}-container"
    
    # 检查容器是否存在
    if ! docker ps -a --format "table {{.Names}}" | grep -q "$container_name"; then
        log_error "Container '$container_name' does not exist. Cannot commit."
        log_error "Please run 'cudo run' to start the container first."
        exit 1
    fi
    
    # 执行提交
    local commit_msg="Commit by cudo at $(date '+%Y-%m-%d %H:%M:%S')"
    log_info "Committing container $container_name to image $IMAGE_NAME..."
    if docker commit -m "$commit_msg" "$container_name" "$IMAGE_NAME"; then
        log_success "Container committed successfully!"
        log_info "New image: $IMAGE_NAME"
        # 显示新镜像ID
        local new_image_id=$(docker image inspect --format='{{.Id}}' "$IMAGE_NAME" 2>/dev/null || echo "unknown")
        log_info "Image ID: ${new_image_id:0:12}"
    else
        log_error "Failed to commit container."
        exit 1
    fi
}

# 重置命令
restore_command() {
    mkdir -p $CONFIG_DIR

    if ! load_config; then
        log_error "Configuration file not found, please run build command first: cudo build"
        exit 1
    fi
    
    save_to_global
    
    log_warning "This will restore the container to the last commit state"
    log_warning "Project: $PROJECT_ROOT"
    log_warning "Image: $IMAGE_NAME"
    echo
    read -p "Confirm restore? Enter 'y' to continue: " confirm
    if [ "$confirm" != "y" ]; then
        log_info "Operation cancelled"
        exit 0
    fi
    
    log_info "Resetting container (delete and recreate)..."
    cd "$CONFIG_DIR"
    docker_compose_cmd down
}

# 日志命令
logs_command() {
    mkdir -p $CONFIG_DIR

    if ! load_config; then
        log_error "Configuration file not found, please run build command first: cudo build"
        exit 1
    fi
    
    save_to_global
    
    cd "$CONFIG_DIR"
    docker_compose_cmd logs -f
}

# 删除命令
remove_command() {
    mkdir -p $CONFIG_DIR

    if ! load_config; then
        log_error "Configuration file not found, please run build command first: cudo build"
        exit 1
    fi
    
    save_to_global
    
    log_warning "This will delete the container, image, and all configuration files"
    log_warning "Project: $PROJECT_ROOT"
    log_warning "Image: $IMAGE_NAME"
    echo
    read -p "Confirm deletion? Enter 'y' to continue: " confirm
    if [ "$confirm" != "y" ]; then
        log_info "Operation cancelled"
        exit 0
    fi
    
    log_info "Cleaning up container and image..."
    cd "$CONFIG_DIR"
    docker_compose_cmd down 2>/dev/null || true
    docker rmi "$IMAGE_NAME" 2>/dev/null || true
    rm -rf "$CONFIG_DIR" 2>/dev/null || true
    remove_from_global
    log_success "All containers, images, and configuration files cleaned up"
}

# 配置命令
config_command() {
    if load_config; then
        echo "Current configuration:"
        echo "  CUDA version: $CUDA_VERSION"
        echo "  Ubuntu version: $UBUNTU_VERSION"
        echo "  CUDA variant: $CUDA_VARIANT"
        echo "  Python version: $PYTHON_VERSION"
        echo "  Image name: $IMAGE_NAME"
        echo "  Unique hash: $UNIQUE_HASH"
    else
        log_info "No configuration found, using defaults:"
        echo "  CUDA version: $DEFAULT_CUDA_VERSION"
        echo "  Ubuntu version: $DEFAULT_UBUNTU_VERSION"
        echo "  CUDA variant: base"
        echo "  Python version: $DEFAULT_PYTHON_VERSION"
        echo "  Image name base: $DEFAULT_IMAGE_NAME_BASE"
        echo "  Note: Actual image name will include a unique hash after build"
    fi
}

# 列出所有 CUDA 环境
list_command() {
    local show_details=${1:-false}
    local show_gpu=${2:-false}
    
    # 使用简化版本的 Python 脚本来显示表格
    local python_script="$PYTHON_SCRIPT_DIR/cuda-env-list-simple.py"
    
    if [ ! -f "$python_script" ]; then
        log_error "Python list script not found: $python_script"
        log_info "Please ensure the Python script is installed in the correct location"
        log_info "Expected location: $PYTHON_SCRIPT_DIR/cuda-env-list-simple.py"
        return 1
    fi
    
    local args=""
    if [ "$show_details" = "true" ]; then
        args="$args --details"
    fi
    if [ "$show_gpu" = "true" ]; then
        args="$args --gpu"
    fi
    
    python3 "$python_script" $args
}

# 显示用法
usage() {
    cat << EOF
Cudo - CUDA Development Environment Manager

Usage: cudo <command> [options]

Commands:
  build [options]    Build CUDA environment image
  run                Start and enter container
  status             Check container status
  start              Start container
  stop               Stop container
  commit             Save container state
  restart            Restart container (preserve state)
  restore            Restore container (restore to the last state)
  logs               View container logs
  remove             Delete container, image and configuration files
  config             Show current configuration
  list [options]     List all CUDA environments
  cleanup            Clean up deleted/moved project configurations
  help               Show this help message

Build options:
  -c, --cuda-version     CUDA version (default: $DEFAULT_CUDA_VERSION)
  -u, --ubuntu-version   Ubuntu version (default: $DEFAULT_UBUNTU_VERSION)
  -t, --with-toolkit     Include CUDA Toolkit (flag, no value needed) (default: $DEFAULT_WITH_TOOLKIT)
  -p, --python-version   Python version (default: $DEFAULT_PYTHON_VERSION)
  -i, --image-name       Image name (default: based on project name)

List options:
  -d, --details      Show detailed resource information (CPU, memory usage, etc.)
  -g, --gpu          Show GPU memory usage information

Examples:
  cudo build -c 11.8.0 -p 3.8
  cudo run
  cudo commit
  cudo restore
  cudo restart
  cudo status
  cudo logs
  cudo config
  cudo list
  cudo list --details
  cudo cleanup
  cudo remove
EOF
}

# 主函数
main() {
    local command=$1
    shift
    
    # 每次执行命令时都更新全局状态
    update_global_status
    
    case $command in
        "build")
            build_command "$@"
            ;;
        "run")
            run_command "$@"
            ;;
        "logs")
            logs_command "$@"
            ;;
        "remove")
            remove_command "$@"
            ;;
        "start")
            start_command "$@"
            ;;
        "stop")
            stop_command "$@"
            ;;
        "commit")
            commit_command "$@"
            ;;
        "restart")
            restart_command "$@"
            ;;
        "restore")
            restore_command "$@"
            ;;
        "status")
            status_command "$@"
            ;;
        "exec")
            run_command "$@"
            ;;
        "config")
            config_command
            ;;
        "list")
            local show_details=false
            local show_gpu=false
            while [[ $# -gt 0 ]]; do
                case $1 in
                    -d|--details)
                        show_details=true
                        shift
                        ;;
                    -g|--gpu)
                        show_gpu=true
                        shift
                        ;;
                    *)
                        shift
                        ;;
                esac
            done
            list_command "$show_details" "$show_gpu"
            ;;
        "cleanup")
            cleanup_deleted_projects
            ;;
        "help"|"-h"|"--help"|"")
            usage
            ;;
        *)
            log_error "Unknown command: $command"
            usage
            exit 1
            ;;
    esac
}

# 运行主函数
main "$@"
